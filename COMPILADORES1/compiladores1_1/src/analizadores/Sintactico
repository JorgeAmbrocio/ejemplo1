package analizadores;

import java_cup.runtime.*;
import java.util.LinkedList;
import arbol.*;
import arbol.expresiones.*;
import arbol.expresiones.aritmeticos.*;
import arbol.expresiones.relacionales.*;
import arbol.expresiones.logicas.*;
import arbol.instrucciones.*;
import arbol.instrucciones.sentencias.*;
import arbol.entorno.*;
import interfaz.*;


parser code 
{:   

    /* Variable que guarda el árbol de sintáxis abstracta generado luego del análisis sintáctico */
    public AST AST;
    
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+".");
            Errores errrores = new Errores(Errores.enumTipoError.sintactico , "Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+".");
    //Interfaz.lista_errores.add(new CError("Sintáctico", "No se esperaba este componente '" + s.value + "'", s.left, s.right));
    
    } 
    /**
     * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
    }  
:}

terminal String mas,menos,por,division,potencia,parizquierdo,parderecho,igual,puntoycoma,llaveizq,llaveder,rint,rdouble,rchar,rboolean,rstring,rclass,coma,rvoid;
terminal String entero,doble,rtrue,rfalse,cadena,caracter,id,rprintln,rprint,rprinttabla;
terminal String menorque,mayorque,menorigualque,mayorigualque,igualigual,diferenteque,or,and,xor,not,rif,relse,rwhile,rbreak,rcontinue,modulo,rfor,rdo,rswitch,rcase,rdefault,dospuntos,interrogacion,masmas,menosmenos,rpow,rreturn,corizquierdo,corderecho,rnew,rpublic,rprotected,rprivate,rabstract,rstatic,rfinal,rstr,rtoDouble,rtoInt,rtoChar,rextends,punto,rthis,rnull,rimport,
rgraph,rsuper,rread_file,rwrite_file,rinstanceof,rread;

terminal umenos; //Para manejar el - E

non terminal INICIO;
non terminal LinkedList<Instruccion> L_INSTRUCCIONES;
non terminal Instruccion INSTRUCCION,DECLARACION,ASIGNACION, IMPRIMIR,BREAK, CONTINUE ,SENTENCIA_IF, SENTENCIA_WHILE, SENTENCIA_SWITCH, SENTENCIA_FOR, ASIGNACION_DECLARACION,SENTENCIA_DO, SENTENCIA_INCREMENTO, SENTENCIA_DECREMENTO, SENTENCIA_IMPORT, FUNCION, METODO;
non terminal Expresion E;
non terminal Tipo T;
non terminal LinkedList<CondicionIf> L_IF;
non terminal LinkedList<CondicionSwitch> L_CASOS;
non terminal LinkedList<Declaracion> PARAMETROS;
non terminal Bloque BLOQUE;



//Operaciones numericas
//precedence left interrogacion; //Así lo tenía antes
precedence right interrogacion,dospuntos;


precedence left or;
precedence left and;
precedence left xor;
precedence right not;

precedence left menorque,menorigualque,mayorque,mayorigualque,igualigual,diferenteque;

precedence left mas,menos;
precedence left por,division,modulo;
precedence left potencia;
precedence left masmas,menosmenos; //Así lo tenía antes

precedence left punto; //Para los accesos

precedence left umenos;

start with INICIO;

INICIO::= L_INSTRUCCIONES:a
    {:
    //se guarda el AST, que es la lista principal de instrucciones en la variable
    //AST que se definió dentro del parser
    
        parser.AST = new AST(a);
    :}
;


L_INSTRUCCIONES ::= L_INSTRUCCIONES:a INSTRUCCION:b {: RESULT = a; RESULT.add(b); :}
                            | INSTRUCCION:a {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= DECLARACION:a puntoycoma {: RESULT = a; :}
            | ASIGNACION:a puntoycoma {: RESULT = a; :}
            | IMPRIMIR:a puntoycoma{: RESULT = a; :}
            | BREAK:a puntoycoma {: RESULT = a ;:}
            | CONTINUE:a puntoycoma {: RESULT = a;:}
            | SENTENCIA_IF:a  {: RESULT = a; :}
            | SENTENCIA_WHILE:a  {: RESULT = a; :}
            | SENTENCIA_SWITCH:a  {: RESULT = a ;:}
            | SENTENCIA_FOR:a  {: RESULT = a ;:}
            | SENTENCIA_DO:a puntoycoma {: RESULT = a; :}
            | SENTENCIA_INCREMENTO:a {: RESULT = a; :}
            | SENTENCIA_DECREMENTO:a {: RESULT = a; :}
            | SENTENCIA_IMPORT:a puntoycoma {: RESULT = a ;:}
            | METODO:a {: RESULT = a; :}
;

METODO ::= T:a id:b parizquierdo PARAMETROS:c parderecho BLOQUE:d {: RESULT = new DeclaraMetodoFuncion(a, b,c,d ); :}
            |T:a id:b parizquierdo parderecho BLOQUE:d {: RESULT = new DeclaraMetodoFuncion(a, b,d ); :}
;

PARAMETROS ::= PARAMETROS:a coma DECLARACION:b {: a.add((Declaracion)b); RESULT = a; :}
            | DECLARACION:a {: RESULT = new LinkedList<>() ; RESULT.add((Declaracion)a); :}
;

SENTENCIA_IMPORT ::= rimport cadena:a {: RESULT = new Import (a , aleft , aright); :}
;

SENTENCIA_INCREMENTO ::= id:a masmas puntoycoma {: RESULT = new InsIncremento( a, aleft, aright) ; :}
;

SENTENCIA_DECREMENTO ::= id:a menosmenos puntoycoma {: RESULT = new InsDecremento( a, aleft, aright) ; :}
;

SENTENCIA_DO ::= rdo BLOQUE:a rwhile parizquierdo E:b parderecho {: RESULT = new Do (b,a); :} 
;

SENTENCIA_FOR ::= rfor parizquierdo ASIGNACION_DECLARACION:a puntoycoma E:b puntoycoma E:c parderecho BLOQUE:d {: RESULT = new For(a,b,c,d); :}
;

ASIGNACION_DECLARACION ::= ASIGNACION:a {: RESULT = a; :}
            | DECLARACION:a {: RESULT = a; :}
;

SENTENCIA_SWITCH ::= rswitch parizquierdo E:a parderecho llaveizq L_CASOS:b llaveder {:RESULT =new Switch(a,b);:}       
;

L_CASOS ::= L_CASOS:a rcase E:b dospuntos L_INSTRUCCIONES:c {: a.add(new CondicionSwitch(b,c)) ; RESULT= a; :}
            |L_CASOS:a rdefault dospuntos L_INSTRUCCIONES:c {: a.add(new CondicionSwitch(c)) ;RESULT = a;:}
            |rcase E:b dospuntos L_INSTRUCCIONES:c {:RESULT = new LinkedList<>(); RESULT.add(new CondicionSwitch(b,c));:}
            |rdefault dospuntos L_INSTRUCCIONES:c {:RESULT = new LinkedList<>(); RESULT.add(new CondicionSwitch(c));:}
;


BREAK ::= rbreak:a {:RESULT = new Break(aleft, aright);:}
;

CONTINUE ::= rcontinue:a {:RESULT = new Continue(aleft, aright);:}
;

SENTENCIA_WHILE ::= rwhile:z parizquierdo:x E:a parderecho:y BLOQUE:b {: RESULT = new While (a, b,zleft, zright) ;:} // crear nueva instruccion
;

SENTENCIA_IF ::= L_IF:a relse BLOQUE:c  {:RESULT = new If (a,c);:} // nuevo if con lista de condiciones con bloque de else
        | L_IF:a {: RESULT = new If (a);:} // crear un nuevo if con lista de condiciones sin bloque de else
;

L_IF ::= L_IF:a relse:z rif:y parizquierdo:x E:b parderecho:w BLOQUE:c {: a.add(new CondicionIf (b, c, bleft, bright)); RESULT = a ; :} // crear linked list y añadir a la lista
        | rif:z parizquierdo:x E:a parderecho:y BLOQUE:b {: RESULT = new LinkedList<>(); RESULT.add(new CondicionIf (a, b, aleft , aright));:} // crear linkedlist de condiciones 
;

BLOQUE ::= llaveizq:z llaveder:y     {: RESULT = new Bloque(); :}
        | llaveizq:z L_INSTRUCCIONES:a llaveder:y {: RESULT = new Bloque(a); :}
;

DECLARACION ::= 
        T:a id:b igual E:c {: RESULT = new Declaracion(a, b, c, bleft, bright); :}
        | T:a id:b {: RESULT = new Declaracion(a, b, bleft, bright); :}
;

ASIGNACION ::= 
                id:a igual E:b {: RESULT = new Asignacion(a,aleft,aright ,b); :}
                //| id:a L_DIMENSIONES_EXPRESION:b igual E:c {: RESULT = new AsignacionArreglo(a,aleft,aright,b,c); :}
;

T ::= rint:a {: RESULT = new Tipo(Tipo.EnumTipo.entero); :}
    | rchar {: RESULT = new Tipo(Tipo.EnumTipo.caracter); :}
    | rboolean {: RESULT = new Tipo(Tipo.EnumTipo.booleano); :}
    | rdouble {: RESULT = new Tipo(Tipo.EnumTipo.doble); :}
    | rstring {: RESULT = new Tipo(Tipo.EnumTipo.cadena); :}
    | rvoid {: RESULT = new Tipo(Tipo.EnumTipo.metodo); :}
;

IMPRIMIR ::= rprintln parizquierdo E:a parderecho {: RESULT = new Imprimir(a,true); :}
    | rprint parizquierdo E:a parderecho {: RESULT = new Imprimir(a,false); :}
;

E ::= 
        entero:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.entero), a); :}
        | caracter:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.caracter), a.replace("\'","")); :}
        //| caracter:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.caracter), a); :}
        | rtrue {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.booleano), true); :}
        | rfalse {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.booleano), false); :}
        | doble:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.doble), a); :}
        | cadena:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.cadena), a ); :}
        //| cadena:a {: RESULT = new Literal(new Tipo(Tipo.EnumTipo.cadena), a); :} este no quita las comillas
        | E:a mas:b E:c {: RESULT = new Suma(aleft, aright, a, c) ; :}
        | E:a menos:b E:c {: RESULT = new Resta (a,c, aleft, aright) ;:}
        | E:a por:b E:c {: RESULT = new Multiplicacion(a,c, aleft, aright);:}
        | E:a division:b E:c {: RESULT = new Division(a,c,aleft,aright); :}
        | E:a potencia:b E:c {: RESULT = new Potencia(a,c,aleft,aright);:}
        | E:a modulo:b E:c {: RESULT  = new Modulo(a,c,aleft,aright);:}
        | id:a {: RESULT = new Id(a, aleft,aright); :}
        | id:a masmas {: RESULT = new ExpIncremento ( a, aleft,aright) ;:}
        | id:a menosmenos {: RESULT = new ExpDecremento( a, aleft,aright) ;:}
        | E:a mayorque:b E:c {: RESULT = new Mayor(a,c,aleft, aright);:}
        | E:a menorque:b E:c {: RESULT = new Menor(a,c,aleft, aright);:}
        | E:a mayorigualque:b E:c {: RESULT = new MayorIgual(a,c,aleft, aright);:}
        | E:a menorigualque:b E:c {: RESULT = new MenorIgual(a,c,aleft, aright);:}
        | E:a igualigual:b E:c {: RESULT = new Igual(a,c,aleft, aright);:}
        | E:a diferenteque:b E:c {: RESULT = new Diferente(a,c,aleft, aright);:}
        | E:a or:b E:c {: RESULT = new O(a,c,aleft,aright);:}
        | E:a and:b E:c {: RESULT = new Y(a,c,aleft,aright);:}
        | E:a xor:b E:c {: RESULT = new Xor(a,c,aleft,aright);:}
        | not:a E:b {: RESULT =new Not(b, aleft,aright);:}
        | menos E:a {:RESULT = new Negativo (a, aleft, aright); :}
        | parizquierdo E:a parderecho {:RESULT = a;:}
        
;





